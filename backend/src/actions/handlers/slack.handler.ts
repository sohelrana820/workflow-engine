import {Injectable, Logger} from '@nestjs/common';
import {BaseActionHandler} from './base-action.handler';
import axios from 'axios';

@Injectable()
export class SlackHandler extends BaseActionHandler {
  private readonly logger = new Logger(SlackHandler.name);

  async execute(config: any): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      this.logger.log('=== Slack Handler Execute ===');
      console.log('Config received:', JSON.stringify(config, null, 2));

      // Extract data from all previous steps to create a comprehensive message
      const customerName = config.name || config.first_name || 'Unknown Customer';
      const customerEmail = config.email || config.event_attendees_email || 'unknown@example.com';
      const company = config.company || 'Unknown Company';
      const jobTitle = config.job_title || 'Unknown Position';
      const eventTitle = config.event_title || 'Upcoming Meeting';
      const eventDate = config.event_date || 'TBD';
      const eventTime = config.event_start_time || 'TBD';
      const aiSummary = config.ai_summary || 'No AI summary available';
      const channel = config.channel || '#general';

      // Create comprehensive Slack message using template variables or default format
      let message = config.message;

      // If message is the default generic message, create a detailed one
      if (!message || message === 'This is a general message' || message.trim() === '') {
        message = this.createDetailedMessage(
          customerName,
          customerEmail,
          company,
          jobTitle,
          eventTitle,
          eventDate,
          eventTime,
          aiSummary
        );
      } else {
        // Replace template variables in the custom message
        message = this.replaceTemplateVariables(message, config);
      }

      // Use webhook URL from config if provided, otherwise from environment
      const webhookToUse = config.webhook_url;

      if (!webhookToUse) {
        console.log('Slack webhook URL not configured, logging message instead');
        console.log('=== SLACK MESSAGE (would be sent to ' + channel + ') ===');
        console.log(message);
        console.log('=== END SLACK MESSAGE ===');

        return {
          success: true,
          data: {
            message: 'Message logged successfully (Slack webhook not configured)',
            channel: channel,
            content: message,
          },
        };
      }

      // Prepare payload for Slack
      const payload = {
        text: message,
        channel: channel,
      };

      try {

        console.log('------------- Sending message to Slack webhook: ' + webhookToUse);

        // Send POST request to Slack webhook
        await axios.post(webhookToUse, payload, {
          timeout: 10000,
        });

        this.logger.log(`Successfully sent message to Slack channel: ${channel}`);

        return {
          success: true,
          data: {
            message: 'Successfully sent notification to Slack',
            channel: channel,
            content: message,
          },
        };
      } catch (slackError) {
        this.logger.error('Slack API error:', slackError.message);

        // Log the message even if Slack fails
        console.log('=== SLACK MESSAGE (failed to send) ===');
        console.log(message);
        console.log('=== END SLACK MESSAGE ===');

        return {
          success: false,
          error: `Failed to send to Slack: ${slackError.message}`,
          data: {
            message: 'Message prepared but failed to send',
            channel: channel,
            content: message,
          },
        };
      }
    } catch (error: any) {
      this.logger.error('Slack notification error:', error);
      return {
        success: false,
        error: error.message || 'Unknown error while sending Slack notification',
      };
    }
  }

  private createDetailedMessage(
    customerName: string,
    customerEmail: string,
    company: string,
    jobTitle: string,
    eventTitle: string,
    eventDate: string,
    eventTime: string,
    aiSummary: string
  ): string {
    return `üóìÔ∏è **Meeting Alert: ${eventTitle}**

üìã **Customer Details:**
‚Ä¢ **Name:** ${customerName}
‚Ä¢ **Email:** ${customerEmail}
‚Ä¢ **Company:** ${company}
‚Ä¢ **Position:** ${jobTitle}

‚è∞ **Meeting Info:**
‚Ä¢ **Date:** ${eventDate}
‚Ä¢ **Time:** ${eventTime}

ü§ñ **AI Summary:**
${aiSummary}

---
*Generated by Workflow Engine*`;
  }

  private replaceTemplateVariables(message: string, data: any): string {
    // Replace template variables like {variable_name}
    let processedMessage = message;

    // Define the mapping of template variables to actual data
    const variableMap = {
      'ai_summary': data.ai_summary || 'No AI summary available',
      'purchase_history': data.purchase_history || 'No purchase history available',
      'interaction_notes': data.interaction_notes || 'No interaction notes available',
      'last_contact_date': data.last_contact_date || 'Unknown',
      'first_name': data.first_name || data.name?.split(' ')[0] || 'Unknown',
      'last_name': data.last_name || data.name?.split(' ')[1] || '',
      'name': data.name || data.first_name || 'Unknown Customer',
      'email': data.email || data.event_attendees_email || 'unknown@example.com',
      'company': data.company || 'Unknown Company',
      'job_title': data.job_title || 'Unknown Position',
      'event_id': data.event_id || '',
      'event_title': data.event_title || 'Upcoming Meeting',
      'event_summery': data.event_summery || data.event_title || 'Meeting',
      'event_description': data.event_description || '',
      'event_start_time': data.event_start_time || 'TBD',
      'event_end_time': data.event_end_time || 'TBD',
      'event_date': data.event_date || 'TBD',
      'event_organizer_name': data.event_organizer_name || 'Unknown',
      'event_attendees_name': data.event_attendees_name || 'Unknown',
      'event_attendees_email': data.event_attendees_email || 'unknown@example.com',
    };

    // Replace {variable} patterns
    for (const [key, value] of Object.entries(variableMap)) {
      const regex = new RegExp(`\\{${key}\\}`, 'g');
      processedMessage = processedMessage.replace(regex, String(value));
    }

    return processedMessage;
  }
}
